// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateCart {
  count: Int!
}

type AggregateCustomer {
  count: Int!
}

type AggregateMenu {
  count: Int!
}

type AggregateMenuChoice {
  count: Int!
}

type AggregateMenuHeader {
  count: Int!
}

type AggregateMenuItem {
  count: Int!
}

type AggregateMenuSelection {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregateOrderItem {
  count: Int!
}

type AggregateOrganization {
  count: Int!
}

type AggregateTable {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Cart {
  id: ID!
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order!]
  customer: User!
  table: Table
  total: Int!
}

type CartConnection {
  pageInfo: PageInfo!
  edges: [CartEdge]!
  aggregate: AggregateCart!
}

input CartCreateInput {
  id: ID
  orders: OrderCreateManyInput
  customer: UserCreateOneInput!
  table: TableCreateOneWithoutCartsInput
  total: Int!
}

input CartCreateManyWithoutTableInput {
  create: [CartCreateWithoutTableInput!]
  connect: [CartWhereUniqueInput!]
}

input CartCreateOneInput {
  create: CartCreateInput
  connect: CartWhereUniqueInput
}

input CartCreateWithoutTableInput {
  id: ID
  orders: OrderCreateManyInput
  customer: UserCreateOneInput!
  total: Int!
}

type CartEdge {
  node: Cart!
  cursor: String!
}

enum CartOrderByInput {
  id_ASC
  id_DESC
  total_ASC
  total_DESC
}

type CartPreviousValues {
  id: ID!
  total: Int!
}

input CartScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  total: Int
  total_not: Int
  total_in: [Int!]
  total_not_in: [Int!]
  total_lt: Int
  total_lte: Int
  total_gt: Int
  total_gte: Int
  AND: [CartScalarWhereInput!]
  OR: [CartScalarWhereInput!]
  NOT: [CartScalarWhereInput!]
}

type CartSubscriptionPayload {
  mutation: MutationType!
  node: Cart
  updatedFields: [String!]
  previousValues: CartPreviousValues
}

input CartSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CartWhereInput
  AND: [CartSubscriptionWhereInput!]
  OR: [CartSubscriptionWhereInput!]
  NOT: [CartSubscriptionWhereInput!]
}

input CartUpdateDataInput {
  orders: OrderUpdateManyInput
  customer: UserUpdateOneRequiredInput
  table: TableUpdateOneWithoutCartsInput
  total: Int
}

input CartUpdateInput {
  orders: OrderUpdateManyInput
  customer: UserUpdateOneRequiredInput
  table: TableUpdateOneWithoutCartsInput
  total: Int
}

input CartUpdateManyDataInput {
  total: Int
}

input CartUpdateManyMutationInput {
  total: Int
}

input CartUpdateManyWithoutTableInput {
  create: [CartCreateWithoutTableInput!]
  delete: [CartWhereUniqueInput!]
  connect: [CartWhereUniqueInput!]
  set: [CartWhereUniqueInput!]
  disconnect: [CartWhereUniqueInput!]
  update: [CartUpdateWithWhereUniqueWithoutTableInput!]
  upsert: [CartUpsertWithWhereUniqueWithoutTableInput!]
  deleteMany: [CartScalarWhereInput!]
  updateMany: [CartUpdateManyWithWhereNestedInput!]
}

input CartUpdateManyWithWhereNestedInput {
  where: CartScalarWhereInput!
  data: CartUpdateManyDataInput!
}

input CartUpdateOneInput {
  create: CartCreateInput
  update: CartUpdateDataInput
  upsert: CartUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CartWhereUniqueInput
}

input CartUpdateWithoutTableDataInput {
  orders: OrderUpdateManyInput
  customer: UserUpdateOneRequiredInput
  total: Int
}

input CartUpdateWithWhereUniqueWithoutTableInput {
  where: CartWhereUniqueInput!
  data: CartUpdateWithoutTableDataInput!
}

input CartUpsertNestedInput {
  update: CartUpdateDataInput!
  create: CartCreateInput!
}

input CartUpsertWithWhereUniqueWithoutTableInput {
  where: CartWhereUniqueInput!
  update: CartUpdateWithoutTableDataInput!
  create: CartCreateWithoutTableInput!
}

input CartWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  orders_every: OrderWhereInput
  orders_some: OrderWhereInput
  orders_none: OrderWhereInput
  customer: UserWhereInput
  table: TableWhereInput
  total: Int
  total_not: Int
  total_in: [Int!]
  total_not_in: [Int!]
  total_lt: Int
  total_lte: Int
  total_gt: Int
  total_gte: Int
  AND: [CartWhereInput!]
  OR: [CartWhereInput!]
  NOT: [CartWhereInput!]
}

input CartWhereUniqueInput {
  id: ID
}

type Customer {
  id: ID!
  email: String!
  name: String
  password: String!
  organizations(where: OrganizationWhereInput, orderBy: OrganizationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Organization!]
  table: Table
  cart: Cart
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order!]
  permissions: Permission!
}

type CustomerConnection {
  pageInfo: PageInfo!
  edges: [CustomerEdge]!
  aggregate: AggregateCustomer!
}

input CustomerCreateInput {
  id: ID
  email: String!
  name: String
  password: String!
  organizations: OrganizationCreateManyWithoutCustomersInput
  table: TableCreateOneInput
  cart: CartCreateOneInput
  orders: OrderCreateManyInput
  permissions: Permission
}

input CustomerCreateManyWithoutOrganizationsInput {
  create: [CustomerCreateWithoutOrganizationsInput!]
  connect: [CustomerWhereUniqueInput!]
}

input CustomerCreateWithoutOrganizationsInput {
  id: ID
  email: String!
  name: String
  password: String!
  table: TableCreateOneInput
  cart: CartCreateOneInput
  orders: OrderCreateManyInput
  permissions: Permission
}

type CustomerEdge {
  node: Customer!
  cursor: String!
}

enum CustomerOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  name_ASC
  name_DESC
  password_ASC
  password_DESC
  permissions_ASC
  permissions_DESC
}

type CustomerPreviousValues {
  id: ID!
  email: String!
  name: String
  password: String!
  permissions: Permission!
}

input CustomerScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  permissions: Permission
  permissions_not: Permission
  permissions_in: [Permission!]
  permissions_not_in: [Permission!]
  AND: [CustomerScalarWhereInput!]
  OR: [CustomerScalarWhereInput!]
  NOT: [CustomerScalarWhereInput!]
}

type CustomerSubscriptionPayload {
  mutation: MutationType!
  node: Customer
  updatedFields: [String!]
  previousValues: CustomerPreviousValues
}

input CustomerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CustomerWhereInput
  AND: [CustomerSubscriptionWhereInput!]
  OR: [CustomerSubscriptionWhereInput!]
  NOT: [CustomerSubscriptionWhereInput!]
}

input CustomerUpdateInput {
  email: String
  name: String
  password: String
  organizations: OrganizationUpdateManyWithoutCustomersInput
  table: TableUpdateOneInput
  cart: CartUpdateOneInput
  orders: OrderUpdateManyInput
  permissions: Permission
}

input CustomerUpdateManyDataInput {
  email: String
  name: String
  password: String
  permissions: Permission
}

input CustomerUpdateManyMutationInput {
  email: String
  name: String
  password: String
  permissions: Permission
}

input CustomerUpdateManyWithoutOrganizationsInput {
  create: [CustomerCreateWithoutOrganizationsInput!]
  delete: [CustomerWhereUniqueInput!]
  connect: [CustomerWhereUniqueInput!]
  set: [CustomerWhereUniqueInput!]
  disconnect: [CustomerWhereUniqueInput!]
  update: [CustomerUpdateWithWhereUniqueWithoutOrganizationsInput!]
  upsert: [CustomerUpsertWithWhereUniqueWithoutOrganizationsInput!]
  deleteMany: [CustomerScalarWhereInput!]
  updateMany: [CustomerUpdateManyWithWhereNestedInput!]
}

input CustomerUpdateManyWithWhereNestedInput {
  where: CustomerScalarWhereInput!
  data: CustomerUpdateManyDataInput!
}

input CustomerUpdateWithoutOrganizationsDataInput {
  email: String
  name: String
  password: String
  table: TableUpdateOneInput
  cart: CartUpdateOneInput
  orders: OrderUpdateManyInput
  permissions: Permission
}

input CustomerUpdateWithWhereUniqueWithoutOrganizationsInput {
  where: CustomerWhereUniqueInput!
  data: CustomerUpdateWithoutOrganizationsDataInput!
}

input CustomerUpsertWithWhereUniqueWithoutOrganizationsInput {
  where: CustomerWhereUniqueInput!
  update: CustomerUpdateWithoutOrganizationsDataInput!
  create: CustomerCreateWithoutOrganizationsInput!
}

input CustomerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  organizations_every: OrganizationWhereInput
  organizations_some: OrganizationWhereInput
  organizations_none: OrganizationWhereInput
  table: TableWhereInput
  cart: CartWhereInput
  orders_every: OrderWhereInput
  orders_some: OrderWhereInput
  orders_none: OrderWhereInput
  permissions: Permission
  permissions_not: Permission
  permissions_in: [Permission!]
  permissions_not_in: [Permission!]
  AND: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
}

input CustomerWhereUniqueInput {
  id: ID
  email: String
}

scalar DateTime

scalar Long

type Menu {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  published: Boolean!
  title: String!
  menu_items(where: MenuItemWhereInput, orderBy: MenuItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuItem!]
  organization: Organization!
}

type MenuChoice {
  id: ID!
  header: String!
  subHeader: String
  selections(where: MenuSelectionWhereInput, orderBy: MenuSelectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuSelection!]
  menu_items(where: MenuItemWhereInput, orderBy: MenuItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuItem!]
}

type MenuChoiceConnection {
  pageInfo: PageInfo!
  edges: [MenuChoiceEdge]!
  aggregate: AggregateMenuChoice!
}

input MenuChoiceCreateInput {
  id: ID
  header: String!
  subHeader: String
  selections: MenuSelectionCreateManyWithoutOptionInput
  menu_items: MenuItemCreateManyWithoutOptionsInput
}

input MenuChoiceCreateManyWithoutMenu_itemsInput {
  create: [MenuChoiceCreateWithoutMenu_itemsInput!]
  connect: [MenuChoiceWhereUniqueInput!]
}

input MenuChoiceCreateOneWithoutSelectionsInput {
  create: MenuChoiceCreateWithoutSelectionsInput
  connect: MenuChoiceWhereUniqueInput
}

input MenuChoiceCreateWithoutMenu_itemsInput {
  id: ID
  header: String!
  subHeader: String
  selections: MenuSelectionCreateManyWithoutOptionInput
}

input MenuChoiceCreateWithoutSelectionsInput {
  id: ID
  header: String!
  subHeader: String
  menu_items: MenuItemCreateManyWithoutOptionsInput
}

type MenuChoiceEdge {
  node: MenuChoice!
  cursor: String!
}

enum MenuChoiceOrderByInput {
  id_ASC
  id_DESC
  header_ASC
  header_DESC
  subHeader_ASC
  subHeader_DESC
}

type MenuChoicePreviousValues {
  id: ID!
  header: String!
  subHeader: String
}

input MenuChoiceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  header: String
  header_not: String
  header_in: [String!]
  header_not_in: [String!]
  header_lt: String
  header_lte: String
  header_gt: String
  header_gte: String
  header_contains: String
  header_not_contains: String
  header_starts_with: String
  header_not_starts_with: String
  header_ends_with: String
  header_not_ends_with: String
  subHeader: String
  subHeader_not: String
  subHeader_in: [String!]
  subHeader_not_in: [String!]
  subHeader_lt: String
  subHeader_lte: String
  subHeader_gt: String
  subHeader_gte: String
  subHeader_contains: String
  subHeader_not_contains: String
  subHeader_starts_with: String
  subHeader_not_starts_with: String
  subHeader_ends_with: String
  subHeader_not_ends_with: String
  AND: [MenuChoiceScalarWhereInput!]
  OR: [MenuChoiceScalarWhereInput!]
  NOT: [MenuChoiceScalarWhereInput!]
}

type MenuChoiceSubscriptionPayload {
  mutation: MutationType!
  node: MenuChoice
  updatedFields: [String!]
  previousValues: MenuChoicePreviousValues
}

input MenuChoiceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MenuChoiceWhereInput
  AND: [MenuChoiceSubscriptionWhereInput!]
  OR: [MenuChoiceSubscriptionWhereInput!]
  NOT: [MenuChoiceSubscriptionWhereInput!]
}

input MenuChoiceUpdateInput {
  header: String
  subHeader: String
  selections: MenuSelectionUpdateManyWithoutOptionInput
  menu_items: MenuItemUpdateManyWithoutOptionsInput
}

input MenuChoiceUpdateManyDataInput {
  header: String
  subHeader: String
}

input MenuChoiceUpdateManyMutationInput {
  header: String
  subHeader: String
}

input MenuChoiceUpdateManyWithoutMenu_itemsInput {
  create: [MenuChoiceCreateWithoutMenu_itemsInput!]
  delete: [MenuChoiceWhereUniqueInput!]
  connect: [MenuChoiceWhereUniqueInput!]
  set: [MenuChoiceWhereUniqueInput!]
  disconnect: [MenuChoiceWhereUniqueInput!]
  update: [MenuChoiceUpdateWithWhereUniqueWithoutMenu_itemsInput!]
  upsert: [MenuChoiceUpsertWithWhereUniqueWithoutMenu_itemsInput!]
  deleteMany: [MenuChoiceScalarWhereInput!]
  updateMany: [MenuChoiceUpdateManyWithWhereNestedInput!]
}

input MenuChoiceUpdateManyWithWhereNestedInput {
  where: MenuChoiceScalarWhereInput!
  data: MenuChoiceUpdateManyDataInput!
}

input MenuChoiceUpdateOneWithoutSelectionsInput {
  create: MenuChoiceCreateWithoutSelectionsInput
  update: MenuChoiceUpdateWithoutSelectionsDataInput
  upsert: MenuChoiceUpsertWithoutSelectionsInput
  delete: Boolean
  disconnect: Boolean
  connect: MenuChoiceWhereUniqueInput
}

input MenuChoiceUpdateWithoutMenu_itemsDataInput {
  header: String
  subHeader: String
  selections: MenuSelectionUpdateManyWithoutOptionInput
}

input MenuChoiceUpdateWithoutSelectionsDataInput {
  header: String
  subHeader: String
  menu_items: MenuItemUpdateManyWithoutOptionsInput
}

input MenuChoiceUpdateWithWhereUniqueWithoutMenu_itemsInput {
  where: MenuChoiceWhereUniqueInput!
  data: MenuChoiceUpdateWithoutMenu_itemsDataInput!
}

input MenuChoiceUpsertWithoutSelectionsInput {
  update: MenuChoiceUpdateWithoutSelectionsDataInput!
  create: MenuChoiceCreateWithoutSelectionsInput!
}

input MenuChoiceUpsertWithWhereUniqueWithoutMenu_itemsInput {
  where: MenuChoiceWhereUniqueInput!
  update: MenuChoiceUpdateWithoutMenu_itemsDataInput!
  create: MenuChoiceCreateWithoutMenu_itemsInput!
}

input MenuChoiceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  header: String
  header_not: String
  header_in: [String!]
  header_not_in: [String!]
  header_lt: String
  header_lte: String
  header_gt: String
  header_gte: String
  header_contains: String
  header_not_contains: String
  header_starts_with: String
  header_not_starts_with: String
  header_ends_with: String
  header_not_ends_with: String
  subHeader: String
  subHeader_not: String
  subHeader_in: [String!]
  subHeader_not_in: [String!]
  subHeader_lt: String
  subHeader_lte: String
  subHeader_gt: String
  subHeader_gte: String
  subHeader_contains: String
  subHeader_not_contains: String
  subHeader_starts_with: String
  subHeader_not_starts_with: String
  subHeader_ends_with: String
  subHeader_not_ends_with: String
  selections_every: MenuSelectionWhereInput
  selections_some: MenuSelectionWhereInput
  selections_none: MenuSelectionWhereInput
  menu_items_every: MenuItemWhereInput
  menu_items_some: MenuItemWhereInput
  menu_items_none: MenuItemWhereInput
  AND: [MenuChoiceWhereInput!]
  OR: [MenuChoiceWhereInput!]
  NOT: [MenuChoiceWhereInput!]
}

input MenuChoiceWhereUniqueInput {
  id: ID
}

type MenuConnection {
  pageInfo: PageInfo!
  edges: [MenuEdge]!
  aggregate: AggregateMenu!
}

input MenuCreateInput {
  id: ID
  published: Boolean
  title: String!
  menu_items: MenuItemCreateManyWithoutMenuInput
  organization: OrganizationCreateOneWithoutMenusInput!
}

input MenuCreateManyWithoutOrganizationInput {
  create: [MenuCreateWithoutOrganizationInput!]
  connect: [MenuWhereUniqueInput!]
}

input MenuCreateOneWithoutMenu_itemsInput {
  create: MenuCreateWithoutMenu_itemsInput
  connect: MenuWhereUniqueInput
}

input MenuCreateWithoutMenu_itemsInput {
  id: ID
  published: Boolean
  title: String!
  organization: OrganizationCreateOneWithoutMenusInput!
}

input MenuCreateWithoutOrganizationInput {
  id: ID
  published: Boolean
  title: String!
  menu_items: MenuItemCreateManyWithoutMenuInput
}

type MenuEdge {
  node: Menu!
  cursor: String!
}

type MenuHeader {
  id: ID!
  name: String!
  subHeader: String
  menu_items(where: MenuItemWhereInput, orderBy: MenuItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuItem!]
}

type MenuHeaderConnection {
  pageInfo: PageInfo!
  edges: [MenuHeaderEdge]!
  aggregate: AggregateMenuHeader!
}

input MenuHeaderCreateInput {
  id: ID
  name: String!
  subHeader: String
  menu_items: MenuItemCreateManyWithoutMenuHeaderInput
}

input MenuHeaderCreateOneWithoutMenu_itemsInput {
  create: MenuHeaderCreateWithoutMenu_itemsInput
  connect: MenuHeaderWhereUniqueInput
}

input MenuHeaderCreateWithoutMenu_itemsInput {
  id: ID
  name: String!
  subHeader: String
}

type MenuHeaderEdge {
  node: MenuHeader!
  cursor: String!
}

enum MenuHeaderOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  subHeader_ASC
  subHeader_DESC
}

type MenuHeaderPreviousValues {
  id: ID!
  name: String!
  subHeader: String
}

type MenuHeaderSubscriptionPayload {
  mutation: MutationType!
  node: MenuHeader
  updatedFields: [String!]
  previousValues: MenuHeaderPreviousValues
}

input MenuHeaderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MenuHeaderWhereInput
  AND: [MenuHeaderSubscriptionWhereInput!]
  OR: [MenuHeaderSubscriptionWhereInput!]
  NOT: [MenuHeaderSubscriptionWhereInput!]
}

input MenuHeaderUpdateInput {
  name: String
  subHeader: String
  menu_items: MenuItemUpdateManyWithoutMenuHeaderInput
}

input MenuHeaderUpdateManyMutationInput {
  name: String
  subHeader: String
}

input MenuHeaderUpdateOneWithoutMenu_itemsInput {
  create: MenuHeaderCreateWithoutMenu_itemsInput
  update: MenuHeaderUpdateWithoutMenu_itemsDataInput
  upsert: MenuHeaderUpsertWithoutMenu_itemsInput
  delete: Boolean
  disconnect: Boolean
  connect: MenuHeaderWhereUniqueInput
}

input MenuHeaderUpdateWithoutMenu_itemsDataInput {
  name: String
  subHeader: String
}

input MenuHeaderUpsertWithoutMenu_itemsInput {
  update: MenuHeaderUpdateWithoutMenu_itemsDataInput!
  create: MenuHeaderCreateWithoutMenu_itemsInput!
}

input MenuHeaderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  subHeader: String
  subHeader_not: String
  subHeader_in: [String!]
  subHeader_not_in: [String!]
  subHeader_lt: String
  subHeader_lte: String
  subHeader_gt: String
  subHeader_gte: String
  subHeader_contains: String
  subHeader_not_contains: String
  subHeader_starts_with: String
  subHeader_not_starts_with: String
  subHeader_ends_with: String
  subHeader_not_ends_with: String
  menu_items_every: MenuItemWhereInput
  menu_items_some: MenuItemWhereInput
  menu_items_none: MenuItemWhereInput
  AND: [MenuHeaderWhereInput!]
  OR: [MenuHeaderWhereInput!]
  NOT: [MenuHeaderWhereInput!]
}

input MenuHeaderWhereUniqueInput {
  id: ID
}

type MenuItem {
  id: ID!
  basePrice: String!
  description: String
  menu: Menu
  options(where: MenuChoiceWhereInput, orderBy: MenuChoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuChoice!]
  name: String!
  image: String
  largeImage: String
  menuHeader: MenuHeader
}

type MenuItemConnection {
  pageInfo: PageInfo!
  edges: [MenuItemEdge]!
  aggregate: AggregateMenuItem!
}

input MenuItemCreateInput {
  id: ID
  basePrice: String!
  description: String
  menu: MenuCreateOneWithoutMenu_itemsInput
  options: MenuChoiceCreateManyWithoutMenu_itemsInput
  name: String!
  image: String
  largeImage: String
  menuHeader: MenuHeaderCreateOneWithoutMenu_itemsInput
}

input MenuItemCreateManyWithoutMenuHeaderInput {
  create: [MenuItemCreateWithoutMenuHeaderInput!]
  connect: [MenuItemWhereUniqueInput!]
}

input MenuItemCreateManyWithoutMenuInput {
  create: [MenuItemCreateWithoutMenuInput!]
  connect: [MenuItemWhereUniqueInput!]
}

input MenuItemCreateManyWithoutOptionsInput {
  create: [MenuItemCreateWithoutOptionsInput!]
  connect: [MenuItemWhereUniqueInput!]
}

input MenuItemCreateWithoutMenuHeaderInput {
  id: ID
  basePrice: String!
  description: String
  menu: MenuCreateOneWithoutMenu_itemsInput
  options: MenuChoiceCreateManyWithoutMenu_itemsInput
  name: String!
  image: String
  largeImage: String
}

input MenuItemCreateWithoutMenuInput {
  id: ID
  basePrice: String!
  description: String
  options: MenuChoiceCreateManyWithoutMenu_itemsInput
  name: String!
  image: String
  largeImage: String
  menuHeader: MenuHeaderCreateOneWithoutMenu_itemsInput
}

input MenuItemCreateWithoutOptionsInput {
  id: ID
  basePrice: String!
  description: String
  menu: MenuCreateOneWithoutMenu_itemsInput
  name: String!
  image: String
  largeImage: String
  menuHeader: MenuHeaderCreateOneWithoutMenu_itemsInput
}

type MenuItemEdge {
  node: MenuItem!
  cursor: String!
}

enum MenuItemOrderByInput {
  id_ASC
  id_DESC
  basePrice_ASC
  basePrice_DESC
  description_ASC
  description_DESC
  name_ASC
  name_DESC
  image_ASC
  image_DESC
  largeImage_ASC
  largeImage_DESC
}

type MenuItemPreviousValues {
  id: ID!
  basePrice: String!
  description: String
  name: String!
  image: String
  largeImage: String
}

input MenuItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  basePrice: String
  basePrice_not: String
  basePrice_in: [String!]
  basePrice_not_in: [String!]
  basePrice_lt: String
  basePrice_lte: String
  basePrice_gt: String
  basePrice_gte: String
  basePrice_contains: String
  basePrice_not_contains: String
  basePrice_starts_with: String
  basePrice_not_starts_with: String
  basePrice_ends_with: String
  basePrice_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  largeImage: String
  largeImage_not: String
  largeImage_in: [String!]
  largeImage_not_in: [String!]
  largeImage_lt: String
  largeImage_lte: String
  largeImage_gt: String
  largeImage_gte: String
  largeImage_contains: String
  largeImage_not_contains: String
  largeImage_starts_with: String
  largeImage_not_starts_with: String
  largeImage_ends_with: String
  largeImage_not_ends_with: String
  AND: [MenuItemScalarWhereInput!]
  OR: [MenuItemScalarWhereInput!]
  NOT: [MenuItemScalarWhereInput!]
}

type MenuItemSubscriptionPayload {
  mutation: MutationType!
  node: MenuItem
  updatedFields: [String!]
  previousValues: MenuItemPreviousValues
}

input MenuItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MenuItemWhereInput
  AND: [MenuItemSubscriptionWhereInput!]
  OR: [MenuItemSubscriptionWhereInput!]
  NOT: [MenuItemSubscriptionWhereInput!]
}

input MenuItemUpdateInput {
  basePrice: String
  description: String
  menu: MenuUpdateOneWithoutMenu_itemsInput
  options: MenuChoiceUpdateManyWithoutMenu_itemsInput
  name: String
  image: String
  largeImage: String
  menuHeader: MenuHeaderUpdateOneWithoutMenu_itemsInput
}

input MenuItemUpdateManyDataInput {
  basePrice: String
  description: String
  name: String
  image: String
  largeImage: String
}

input MenuItemUpdateManyMutationInput {
  basePrice: String
  description: String
  name: String
  image: String
  largeImage: String
}

input MenuItemUpdateManyWithoutMenuHeaderInput {
  create: [MenuItemCreateWithoutMenuHeaderInput!]
  delete: [MenuItemWhereUniqueInput!]
  connect: [MenuItemWhereUniqueInput!]
  set: [MenuItemWhereUniqueInput!]
  disconnect: [MenuItemWhereUniqueInput!]
  update: [MenuItemUpdateWithWhereUniqueWithoutMenuHeaderInput!]
  upsert: [MenuItemUpsertWithWhereUniqueWithoutMenuHeaderInput!]
  deleteMany: [MenuItemScalarWhereInput!]
  updateMany: [MenuItemUpdateManyWithWhereNestedInput!]
}

input MenuItemUpdateManyWithoutMenuInput {
  create: [MenuItemCreateWithoutMenuInput!]
  delete: [MenuItemWhereUniqueInput!]
  connect: [MenuItemWhereUniqueInput!]
  set: [MenuItemWhereUniqueInput!]
  disconnect: [MenuItemWhereUniqueInput!]
  update: [MenuItemUpdateWithWhereUniqueWithoutMenuInput!]
  upsert: [MenuItemUpsertWithWhereUniqueWithoutMenuInput!]
  deleteMany: [MenuItemScalarWhereInput!]
  updateMany: [MenuItemUpdateManyWithWhereNestedInput!]
}

input MenuItemUpdateManyWithoutOptionsInput {
  create: [MenuItemCreateWithoutOptionsInput!]
  delete: [MenuItemWhereUniqueInput!]
  connect: [MenuItemWhereUniqueInput!]
  set: [MenuItemWhereUniqueInput!]
  disconnect: [MenuItemWhereUniqueInput!]
  update: [MenuItemUpdateWithWhereUniqueWithoutOptionsInput!]
  upsert: [MenuItemUpsertWithWhereUniqueWithoutOptionsInput!]
  deleteMany: [MenuItemScalarWhereInput!]
  updateMany: [MenuItemUpdateManyWithWhereNestedInput!]
}

input MenuItemUpdateManyWithWhereNestedInput {
  where: MenuItemScalarWhereInput!
  data: MenuItemUpdateManyDataInput!
}

input MenuItemUpdateWithoutMenuDataInput {
  basePrice: String
  description: String
  options: MenuChoiceUpdateManyWithoutMenu_itemsInput
  name: String
  image: String
  largeImage: String
  menuHeader: MenuHeaderUpdateOneWithoutMenu_itemsInput
}

input MenuItemUpdateWithoutMenuHeaderDataInput {
  basePrice: String
  description: String
  menu: MenuUpdateOneWithoutMenu_itemsInput
  options: MenuChoiceUpdateManyWithoutMenu_itemsInput
  name: String
  image: String
  largeImage: String
}

input MenuItemUpdateWithoutOptionsDataInput {
  basePrice: String
  description: String
  menu: MenuUpdateOneWithoutMenu_itemsInput
  name: String
  image: String
  largeImage: String
  menuHeader: MenuHeaderUpdateOneWithoutMenu_itemsInput
}

input MenuItemUpdateWithWhereUniqueWithoutMenuHeaderInput {
  where: MenuItemWhereUniqueInput!
  data: MenuItemUpdateWithoutMenuHeaderDataInput!
}

input MenuItemUpdateWithWhereUniqueWithoutMenuInput {
  where: MenuItemWhereUniqueInput!
  data: MenuItemUpdateWithoutMenuDataInput!
}

input MenuItemUpdateWithWhereUniqueWithoutOptionsInput {
  where: MenuItemWhereUniqueInput!
  data: MenuItemUpdateWithoutOptionsDataInput!
}

input MenuItemUpsertWithWhereUniqueWithoutMenuHeaderInput {
  where: MenuItemWhereUniqueInput!
  update: MenuItemUpdateWithoutMenuHeaderDataInput!
  create: MenuItemCreateWithoutMenuHeaderInput!
}

input MenuItemUpsertWithWhereUniqueWithoutMenuInput {
  where: MenuItemWhereUniqueInput!
  update: MenuItemUpdateWithoutMenuDataInput!
  create: MenuItemCreateWithoutMenuInput!
}

input MenuItemUpsertWithWhereUniqueWithoutOptionsInput {
  where: MenuItemWhereUniqueInput!
  update: MenuItemUpdateWithoutOptionsDataInput!
  create: MenuItemCreateWithoutOptionsInput!
}

input MenuItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  basePrice: String
  basePrice_not: String
  basePrice_in: [String!]
  basePrice_not_in: [String!]
  basePrice_lt: String
  basePrice_lte: String
  basePrice_gt: String
  basePrice_gte: String
  basePrice_contains: String
  basePrice_not_contains: String
  basePrice_starts_with: String
  basePrice_not_starts_with: String
  basePrice_ends_with: String
  basePrice_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  menu: MenuWhereInput
  options_every: MenuChoiceWhereInput
  options_some: MenuChoiceWhereInput
  options_none: MenuChoiceWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  largeImage: String
  largeImage_not: String
  largeImage_in: [String!]
  largeImage_not_in: [String!]
  largeImage_lt: String
  largeImage_lte: String
  largeImage_gt: String
  largeImage_gte: String
  largeImage_contains: String
  largeImage_not_contains: String
  largeImage_starts_with: String
  largeImage_not_starts_with: String
  largeImage_ends_with: String
  largeImage_not_ends_with: String
  menuHeader: MenuHeaderWhereInput
  AND: [MenuItemWhereInput!]
  OR: [MenuItemWhereInput!]
  NOT: [MenuItemWhereInput!]
}

input MenuItemWhereUniqueInput {
  id: ID
}

enum MenuOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  published_ASC
  published_DESC
  title_ASC
  title_DESC
}

type MenuPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  published: Boolean!
  title: String!
}

input MenuScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  published: Boolean
  published_not: Boolean
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [MenuScalarWhereInput!]
  OR: [MenuScalarWhereInput!]
  NOT: [MenuScalarWhereInput!]
}

type MenuSelection {
  id: ID!
  name: String!
  selected: Boolean
  valueAdd: String
  option: MenuChoice
}

type MenuSelectionConnection {
  pageInfo: PageInfo!
  edges: [MenuSelectionEdge]!
  aggregate: AggregateMenuSelection!
}

input MenuSelectionCreateInput {
  id: ID
  name: String!
  selected: Boolean
  valueAdd: String
  option: MenuChoiceCreateOneWithoutSelectionsInput
}

input MenuSelectionCreateManyWithoutOptionInput {
  create: [MenuSelectionCreateWithoutOptionInput!]
  connect: [MenuSelectionWhereUniqueInput!]
}

input MenuSelectionCreateWithoutOptionInput {
  id: ID
  name: String!
  selected: Boolean
  valueAdd: String
}

type MenuSelectionEdge {
  node: MenuSelection!
  cursor: String!
}

enum MenuSelectionOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  selected_ASC
  selected_DESC
  valueAdd_ASC
  valueAdd_DESC
}

type MenuSelectionPreviousValues {
  id: ID!
  name: String!
  selected: Boolean
  valueAdd: String
}

input MenuSelectionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  selected: Boolean
  selected_not: Boolean
  valueAdd: String
  valueAdd_not: String
  valueAdd_in: [String!]
  valueAdd_not_in: [String!]
  valueAdd_lt: String
  valueAdd_lte: String
  valueAdd_gt: String
  valueAdd_gte: String
  valueAdd_contains: String
  valueAdd_not_contains: String
  valueAdd_starts_with: String
  valueAdd_not_starts_with: String
  valueAdd_ends_with: String
  valueAdd_not_ends_with: String
  AND: [MenuSelectionScalarWhereInput!]
  OR: [MenuSelectionScalarWhereInput!]
  NOT: [MenuSelectionScalarWhereInput!]
}

type MenuSelectionSubscriptionPayload {
  mutation: MutationType!
  node: MenuSelection
  updatedFields: [String!]
  previousValues: MenuSelectionPreviousValues
}

input MenuSelectionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MenuSelectionWhereInput
  AND: [MenuSelectionSubscriptionWhereInput!]
  OR: [MenuSelectionSubscriptionWhereInput!]
  NOT: [MenuSelectionSubscriptionWhereInput!]
}

input MenuSelectionUpdateInput {
  name: String
  selected: Boolean
  valueAdd: String
  option: MenuChoiceUpdateOneWithoutSelectionsInput
}

input MenuSelectionUpdateManyDataInput {
  name: String
  selected: Boolean
  valueAdd: String
}

input MenuSelectionUpdateManyMutationInput {
  name: String
  selected: Boolean
  valueAdd: String
}

input MenuSelectionUpdateManyWithoutOptionInput {
  create: [MenuSelectionCreateWithoutOptionInput!]
  delete: [MenuSelectionWhereUniqueInput!]
  connect: [MenuSelectionWhereUniqueInput!]
  set: [MenuSelectionWhereUniqueInput!]
  disconnect: [MenuSelectionWhereUniqueInput!]
  update: [MenuSelectionUpdateWithWhereUniqueWithoutOptionInput!]
  upsert: [MenuSelectionUpsertWithWhereUniqueWithoutOptionInput!]
  deleteMany: [MenuSelectionScalarWhereInput!]
  updateMany: [MenuSelectionUpdateManyWithWhereNestedInput!]
}

input MenuSelectionUpdateManyWithWhereNestedInput {
  where: MenuSelectionScalarWhereInput!
  data: MenuSelectionUpdateManyDataInput!
}

input MenuSelectionUpdateWithoutOptionDataInput {
  name: String
  selected: Boolean
  valueAdd: String
}

input MenuSelectionUpdateWithWhereUniqueWithoutOptionInput {
  where: MenuSelectionWhereUniqueInput!
  data: MenuSelectionUpdateWithoutOptionDataInput!
}

input MenuSelectionUpsertWithWhereUniqueWithoutOptionInput {
  where: MenuSelectionWhereUniqueInput!
  update: MenuSelectionUpdateWithoutOptionDataInput!
  create: MenuSelectionCreateWithoutOptionInput!
}

input MenuSelectionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  selected: Boolean
  selected_not: Boolean
  valueAdd: String
  valueAdd_not: String
  valueAdd_in: [String!]
  valueAdd_not_in: [String!]
  valueAdd_lt: String
  valueAdd_lte: String
  valueAdd_gt: String
  valueAdd_gte: String
  valueAdd_contains: String
  valueAdd_not_contains: String
  valueAdd_starts_with: String
  valueAdd_not_starts_with: String
  valueAdd_ends_with: String
  valueAdd_not_ends_with: String
  option: MenuChoiceWhereInput
  AND: [MenuSelectionWhereInput!]
  OR: [MenuSelectionWhereInput!]
  NOT: [MenuSelectionWhereInput!]
}

input MenuSelectionWhereUniqueInput {
  id: ID
}

type MenuSubscriptionPayload {
  mutation: MutationType!
  node: Menu
  updatedFields: [String!]
  previousValues: MenuPreviousValues
}

input MenuSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MenuWhereInput
  AND: [MenuSubscriptionWhereInput!]
  OR: [MenuSubscriptionWhereInput!]
  NOT: [MenuSubscriptionWhereInput!]
}

input MenuUpdateInput {
  published: Boolean
  title: String
  menu_items: MenuItemUpdateManyWithoutMenuInput
  organization: OrganizationUpdateOneRequiredWithoutMenusInput
}

input MenuUpdateManyDataInput {
  published: Boolean
  title: String
}

input MenuUpdateManyMutationInput {
  published: Boolean
  title: String
}

input MenuUpdateManyWithoutOrganizationInput {
  create: [MenuCreateWithoutOrganizationInput!]
  delete: [MenuWhereUniqueInput!]
  connect: [MenuWhereUniqueInput!]
  set: [MenuWhereUniqueInput!]
  disconnect: [MenuWhereUniqueInput!]
  update: [MenuUpdateWithWhereUniqueWithoutOrganizationInput!]
  upsert: [MenuUpsertWithWhereUniqueWithoutOrganizationInput!]
  deleteMany: [MenuScalarWhereInput!]
  updateMany: [MenuUpdateManyWithWhereNestedInput!]
}

input MenuUpdateManyWithWhereNestedInput {
  where: MenuScalarWhereInput!
  data: MenuUpdateManyDataInput!
}

input MenuUpdateOneWithoutMenu_itemsInput {
  create: MenuCreateWithoutMenu_itemsInput
  update: MenuUpdateWithoutMenu_itemsDataInput
  upsert: MenuUpsertWithoutMenu_itemsInput
  delete: Boolean
  disconnect: Boolean
  connect: MenuWhereUniqueInput
}

input MenuUpdateWithoutMenu_itemsDataInput {
  published: Boolean
  title: String
  organization: OrganizationUpdateOneRequiredWithoutMenusInput
}

input MenuUpdateWithoutOrganizationDataInput {
  published: Boolean
  title: String
  menu_items: MenuItemUpdateManyWithoutMenuInput
}

input MenuUpdateWithWhereUniqueWithoutOrganizationInput {
  where: MenuWhereUniqueInput!
  data: MenuUpdateWithoutOrganizationDataInput!
}

input MenuUpsertWithoutMenu_itemsInput {
  update: MenuUpdateWithoutMenu_itemsDataInput!
  create: MenuCreateWithoutMenu_itemsInput!
}

input MenuUpsertWithWhereUniqueWithoutOrganizationInput {
  where: MenuWhereUniqueInput!
  update: MenuUpdateWithoutOrganizationDataInput!
  create: MenuCreateWithoutOrganizationInput!
}

input MenuWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  published: Boolean
  published_not: Boolean
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  menu_items_every: MenuItemWhereInput
  menu_items_some: MenuItemWhereInput
  menu_items_none: MenuItemWhereInput
  organization: OrganizationWhereInput
  AND: [MenuWhereInput!]
  OR: [MenuWhereInput!]
  NOT: [MenuWhereInput!]
}

input MenuWhereUniqueInput {
  id: ID
}

type Mutation {
  createCart(data: CartCreateInput!): Cart!
  updateCart(data: CartUpdateInput!, where: CartWhereUniqueInput!): Cart
  updateManyCarts(data: CartUpdateManyMutationInput!, where: CartWhereInput): BatchPayload!
  upsertCart(where: CartWhereUniqueInput!, create: CartCreateInput!, update: CartUpdateInput!): Cart!
  deleteCart(where: CartWhereUniqueInput!): Cart
  deleteManyCarts(where: CartWhereInput): BatchPayload!
  createCustomer(data: CustomerCreateInput!): Customer!
  updateCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateManyCustomers(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): BatchPayload!
  upsertCustomer(where: CustomerWhereUniqueInput!, create: CustomerCreateInput!, update: CustomerUpdateInput!): Customer!
  deleteCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteManyCustomers(where: CustomerWhereInput): BatchPayload!
  createMenu(data: MenuCreateInput!): Menu!
  updateMenu(data: MenuUpdateInput!, where: MenuWhereUniqueInput!): Menu
  updateManyMenus(data: MenuUpdateManyMutationInput!, where: MenuWhereInput): BatchPayload!
  upsertMenu(where: MenuWhereUniqueInput!, create: MenuCreateInput!, update: MenuUpdateInput!): Menu!
  deleteMenu(where: MenuWhereUniqueInput!): Menu
  deleteManyMenus(where: MenuWhereInput): BatchPayload!
  createMenuChoice(data: MenuChoiceCreateInput!): MenuChoice!
  updateMenuChoice(data: MenuChoiceUpdateInput!, where: MenuChoiceWhereUniqueInput!): MenuChoice
  updateManyMenuChoices(data: MenuChoiceUpdateManyMutationInput!, where: MenuChoiceWhereInput): BatchPayload!
  upsertMenuChoice(where: MenuChoiceWhereUniqueInput!, create: MenuChoiceCreateInput!, update: MenuChoiceUpdateInput!): MenuChoice!
  deleteMenuChoice(where: MenuChoiceWhereUniqueInput!): MenuChoice
  deleteManyMenuChoices(where: MenuChoiceWhereInput): BatchPayload!
  createMenuHeader(data: MenuHeaderCreateInput!): MenuHeader!
  updateMenuHeader(data: MenuHeaderUpdateInput!, where: MenuHeaderWhereUniqueInput!): MenuHeader
  updateManyMenuHeaders(data: MenuHeaderUpdateManyMutationInput!, where: MenuHeaderWhereInput): BatchPayload!
  upsertMenuHeader(where: MenuHeaderWhereUniqueInput!, create: MenuHeaderCreateInput!, update: MenuHeaderUpdateInput!): MenuHeader!
  deleteMenuHeader(where: MenuHeaderWhereUniqueInput!): MenuHeader
  deleteManyMenuHeaders(where: MenuHeaderWhereInput): BatchPayload!
  createMenuItem(data: MenuItemCreateInput!): MenuItem!
  updateMenuItem(data: MenuItemUpdateInput!, where: MenuItemWhereUniqueInput!): MenuItem
  updateManyMenuItems(data: MenuItemUpdateManyMutationInput!, where: MenuItemWhereInput): BatchPayload!
  upsertMenuItem(where: MenuItemWhereUniqueInput!, create: MenuItemCreateInput!, update: MenuItemUpdateInput!): MenuItem!
  deleteMenuItem(where: MenuItemWhereUniqueInput!): MenuItem
  deleteManyMenuItems(where: MenuItemWhereInput): BatchPayload!
  createMenuSelection(data: MenuSelectionCreateInput!): MenuSelection!
  updateMenuSelection(data: MenuSelectionUpdateInput!, where: MenuSelectionWhereUniqueInput!): MenuSelection
  updateManyMenuSelections(data: MenuSelectionUpdateManyMutationInput!, where: MenuSelectionWhereInput): BatchPayload!
  upsertMenuSelection(where: MenuSelectionWhereUniqueInput!, create: MenuSelectionCreateInput!, update: MenuSelectionUpdateInput!): MenuSelection!
  deleteMenuSelection(where: MenuSelectionWhereUniqueInput!): MenuSelection
  deleteManyMenuSelections(where: MenuSelectionWhereInput): BatchPayload!
  createOrder(data: OrderCreateInput!): Order!
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateManyOrders(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): BatchPayload!
  upsertOrder(where: OrderWhereUniqueInput!, create: OrderCreateInput!, update: OrderUpdateInput!): Order!
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  createOrderItem(data: OrderItemCreateInput!): OrderItem!
  updateOrderItem(data: OrderItemUpdateInput!, where: OrderItemWhereUniqueInput!): OrderItem
  updateManyOrderItems(data: OrderItemUpdateManyMutationInput!, where: OrderItemWhereInput): BatchPayload!
  upsertOrderItem(where: OrderItemWhereUniqueInput!, create: OrderItemCreateInput!, update: OrderItemUpdateInput!): OrderItem!
  deleteOrderItem(where: OrderItemWhereUniqueInput!): OrderItem
  deleteManyOrderItems(where: OrderItemWhereInput): BatchPayload!
  createOrganization(data: OrganizationCreateInput!): Organization!
  updateOrganization(data: OrganizationUpdateInput!, where: OrganizationWhereUniqueInput!): Organization
  updateManyOrganizations(data: OrganizationUpdateManyMutationInput!, where: OrganizationWhereInput): BatchPayload!
  upsertOrganization(where: OrganizationWhereUniqueInput!, create: OrganizationCreateInput!, update: OrganizationUpdateInput!): Organization!
  deleteOrganization(where: OrganizationWhereUniqueInput!): Organization
  deleteManyOrganizations(where: OrganizationWhereInput): BatchPayload!
  createTable(data: TableCreateInput!): Table!
  updateTable(data: TableUpdateInput!, where: TableWhereUniqueInput!): Table
  upsertTable(where: TableWhereUniqueInput!, create: TableCreateInput!, update: TableUpdateInput!): Table!
  deleteTable(where: TableWhereUniqueInput!): Table
  deleteManyTables(where: TableWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Order {
  id: ID!
  items(where: OrderItemWhereInput, orderBy: OrderItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderItem!]
  total: Int!
  customer: User!
  charge: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

input OrderCreateInput {
  id: ID
  items: OrderItemCreateManyInput
  total: Int!
  customer: UserCreateOneInput!
  charge: String!
}

input OrderCreateManyInput {
  create: [OrderCreateInput!]
  connect: [OrderWhereUniqueInput!]
}

type OrderEdge {
  node: Order!
  cursor: String!
}

type OrderItem {
  id: ID!
  title: String!
  price: Int!
  quantity: Int!
  customer: User!
}

type OrderItemConnection {
  pageInfo: PageInfo!
  edges: [OrderItemEdge]!
  aggregate: AggregateOrderItem!
}

input OrderItemCreateInput {
  id: ID
  title: String!
  price: Int!
  quantity: Int
  customer: UserCreateOneInput!
}

input OrderItemCreateManyInput {
  create: [OrderItemCreateInput!]
  connect: [OrderItemWhereUniqueInput!]
}

type OrderItemEdge {
  node: OrderItem!
  cursor: String!
}

enum OrderItemOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  price_ASC
  price_DESC
  quantity_ASC
  quantity_DESC
}

type OrderItemPreviousValues {
  id: ID!
  title: String!
  price: Int!
  quantity: Int!
}

input OrderItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  AND: [OrderItemScalarWhereInput!]
  OR: [OrderItemScalarWhereInput!]
  NOT: [OrderItemScalarWhereInput!]
}

type OrderItemSubscriptionPayload {
  mutation: MutationType!
  node: OrderItem
  updatedFields: [String!]
  previousValues: OrderItemPreviousValues
}

input OrderItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderItemWhereInput
  AND: [OrderItemSubscriptionWhereInput!]
  OR: [OrderItemSubscriptionWhereInput!]
  NOT: [OrderItemSubscriptionWhereInput!]
}

input OrderItemUpdateDataInput {
  title: String
  price: Int
  quantity: Int
  customer: UserUpdateOneRequiredInput
}

input OrderItemUpdateInput {
  title: String
  price: Int
  quantity: Int
  customer: UserUpdateOneRequiredInput
}

input OrderItemUpdateManyDataInput {
  title: String
  price: Int
  quantity: Int
}

input OrderItemUpdateManyInput {
  create: [OrderItemCreateInput!]
  update: [OrderItemUpdateWithWhereUniqueNestedInput!]
  upsert: [OrderItemUpsertWithWhereUniqueNestedInput!]
  delete: [OrderItemWhereUniqueInput!]
  connect: [OrderItemWhereUniqueInput!]
  set: [OrderItemWhereUniqueInput!]
  disconnect: [OrderItemWhereUniqueInput!]
  deleteMany: [OrderItemScalarWhereInput!]
  updateMany: [OrderItemUpdateManyWithWhereNestedInput!]
}

input OrderItemUpdateManyMutationInput {
  title: String
  price: Int
  quantity: Int
}

input OrderItemUpdateManyWithWhereNestedInput {
  where: OrderItemScalarWhereInput!
  data: OrderItemUpdateManyDataInput!
}

input OrderItemUpdateWithWhereUniqueNestedInput {
  where: OrderItemWhereUniqueInput!
  data: OrderItemUpdateDataInput!
}

input OrderItemUpsertWithWhereUniqueNestedInput {
  where: OrderItemWhereUniqueInput!
  update: OrderItemUpdateDataInput!
  create: OrderItemCreateInput!
}

input OrderItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  customer: UserWhereInput
  AND: [OrderItemWhereInput!]
  OR: [OrderItemWhereInput!]
  NOT: [OrderItemWhereInput!]
}

input OrderItemWhereUniqueInput {
  id: ID
}

enum OrderOrderByInput {
  id_ASC
  id_DESC
  total_ASC
  total_DESC
  charge_ASC
  charge_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type OrderPreviousValues {
  id: ID!
  total: Int!
  charge: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input OrderScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  total: Int
  total_not: Int
  total_in: [Int!]
  total_not_in: [Int!]
  total_lt: Int
  total_lte: Int
  total_gt: Int
  total_gte: Int
  charge: String
  charge_not: String
  charge_in: [String!]
  charge_not_in: [String!]
  charge_lt: String
  charge_lte: String
  charge_gt: String
  charge_gte: String
  charge_contains: String
  charge_not_contains: String
  charge_starts_with: String
  charge_not_starts_with: String
  charge_ends_with: String
  charge_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [OrderScalarWhereInput!]
  OR: [OrderScalarWhereInput!]
  NOT: [OrderScalarWhereInput!]
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
  AND: [OrderSubscriptionWhereInput!]
  OR: [OrderSubscriptionWhereInput!]
  NOT: [OrderSubscriptionWhereInput!]
}

input OrderUpdateDataInput {
  items: OrderItemUpdateManyInput
  total: Int
  customer: UserUpdateOneRequiredInput
  charge: String
}

input OrderUpdateInput {
  items: OrderItemUpdateManyInput
  total: Int
  customer: UserUpdateOneRequiredInput
  charge: String
}

input OrderUpdateManyDataInput {
  total: Int
  charge: String
}

input OrderUpdateManyInput {
  create: [OrderCreateInput!]
  update: [OrderUpdateWithWhereUniqueNestedInput!]
  upsert: [OrderUpsertWithWhereUniqueNestedInput!]
  delete: [OrderWhereUniqueInput!]
  connect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  disconnect: [OrderWhereUniqueInput!]
  deleteMany: [OrderScalarWhereInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
}

input OrderUpdateManyMutationInput {
  total: Int
  charge: String
}

input OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput!
  data: OrderUpdateManyDataInput!
}

input OrderUpdateWithWhereUniqueNestedInput {
  where: OrderWhereUniqueInput!
  data: OrderUpdateDataInput!
}

input OrderUpsertWithWhereUniqueNestedInput {
  where: OrderWhereUniqueInput!
  update: OrderUpdateDataInput!
  create: OrderCreateInput!
}

input OrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  items_every: OrderItemWhereInput
  items_some: OrderItemWhereInput
  items_none: OrderItemWhereInput
  total: Int
  total_not: Int
  total_in: [Int!]
  total_not_in: [Int!]
  total_lt: Int
  total_lte: Int
  total_gt: Int
  total_gte: Int
  customer: UserWhereInput
  charge: String
  charge_not: String
  charge_in: [String!]
  charge_not_in: [String!]
  charge_lt: String
  charge_lte: String
  charge_gt: String
  charge_gte: String
  charge_contains: String
  charge_not_contains: String
  charge_starts_with: String
  charge_not_starts_with: String
  charge_ends_with: String
  charge_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
}

input OrderWhereUniqueInput {
  id: ID
}

type Organization {
  id: ID!
  name: String!
  menus(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Menu!]
  admins(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  customers(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Customer!]
}

type OrganizationConnection {
  pageInfo: PageInfo!
  edges: [OrganizationEdge]!
  aggregate: AggregateOrganization!
}

input OrganizationCreateInput {
  id: ID
  name: String!
  menus: MenuCreateManyWithoutOrganizationInput
  admins: UserCreateManyWithoutOrganizationsInput
  customers: CustomerCreateManyWithoutOrganizationsInput
}

input OrganizationCreateManyWithoutAdminsInput {
  create: [OrganizationCreateWithoutAdminsInput!]
  connect: [OrganizationWhereUniqueInput!]
}

input OrganizationCreateManyWithoutCustomersInput {
  create: [OrganizationCreateWithoutCustomersInput!]
  connect: [OrganizationWhereUniqueInput!]
}

input OrganizationCreateOneWithoutMenusInput {
  create: OrganizationCreateWithoutMenusInput
  connect: OrganizationWhereUniqueInput
}

input OrganizationCreateWithoutAdminsInput {
  id: ID
  name: String!
  menus: MenuCreateManyWithoutOrganizationInput
  customers: CustomerCreateManyWithoutOrganizationsInput
}

input OrganizationCreateWithoutCustomersInput {
  id: ID
  name: String!
  menus: MenuCreateManyWithoutOrganizationInput
  admins: UserCreateManyWithoutOrganizationsInput
}

input OrganizationCreateWithoutMenusInput {
  id: ID
  name: String!
  admins: UserCreateManyWithoutOrganizationsInput
  customers: CustomerCreateManyWithoutOrganizationsInput
}

type OrganizationEdge {
  node: Organization!
  cursor: String!
}

enum OrganizationOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type OrganizationPreviousValues {
  id: ID!
  name: String!
}

input OrganizationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [OrganizationScalarWhereInput!]
  OR: [OrganizationScalarWhereInput!]
  NOT: [OrganizationScalarWhereInput!]
}

type OrganizationSubscriptionPayload {
  mutation: MutationType!
  node: Organization
  updatedFields: [String!]
  previousValues: OrganizationPreviousValues
}

input OrganizationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrganizationWhereInput
  AND: [OrganizationSubscriptionWhereInput!]
  OR: [OrganizationSubscriptionWhereInput!]
  NOT: [OrganizationSubscriptionWhereInput!]
}

input OrganizationUpdateInput {
  name: String
  menus: MenuUpdateManyWithoutOrganizationInput
  admins: UserUpdateManyWithoutOrganizationsInput
  customers: CustomerUpdateManyWithoutOrganizationsInput
}

input OrganizationUpdateManyDataInput {
  name: String
}

input OrganizationUpdateManyMutationInput {
  name: String
}

input OrganizationUpdateManyWithoutAdminsInput {
  create: [OrganizationCreateWithoutAdminsInput!]
  delete: [OrganizationWhereUniqueInput!]
  connect: [OrganizationWhereUniqueInput!]
  set: [OrganizationWhereUniqueInput!]
  disconnect: [OrganizationWhereUniqueInput!]
  update: [OrganizationUpdateWithWhereUniqueWithoutAdminsInput!]
  upsert: [OrganizationUpsertWithWhereUniqueWithoutAdminsInput!]
  deleteMany: [OrganizationScalarWhereInput!]
  updateMany: [OrganizationUpdateManyWithWhereNestedInput!]
}

input OrganizationUpdateManyWithoutCustomersInput {
  create: [OrganizationCreateWithoutCustomersInput!]
  delete: [OrganizationWhereUniqueInput!]
  connect: [OrganizationWhereUniqueInput!]
  set: [OrganizationWhereUniqueInput!]
  disconnect: [OrganizationWhereUniqueInput!]
  update: [OrganizationUpdateWithWhereUniqueWithoutCustomersInput!]
  upsert: [OrganizationUpsertWithWhereUniqueWithoutCustomersInput!]
  deleteMany: [OrganizationScalarWhereInput!]
  updateMany: [OrganizationUpdateManyWithWhereNestedInput!]
}

input OrganizationUpdateManyWithWhereNestedInput {
  where: OrganizationScalarWhereInput!
  data: OrganizationUpdateManyDataInput!
}

input OrganizationUpdateOneRequiredWithoutMenusInput {
  create: OrganizationCreateWithoutMenusInput
  update: OrganizationUpdateWithoutMenusDataInput
  upsert: OrganizationUpsertWithoutMenusInput
  connect: OrganizationWhereUniqueInput
}

input OrganizationUpdateWithoutAdminsDataInput {
  name: String
  menus: MenuUpdateManyWithoutOrganizationInput
  customers: CustomerUpdateManyWithoutOrganizationsInput
}

input OrganizationUpdateWithoutCustomersDataInput {
  name: String
  menus: MenuUpdateManyWithoutOrganizationInput
  admins: UserUpdateManyWithoutOrganizationsInput
}

input OrganizationUpdateWithoutMenusDataInput {
  name: String
  admins: UserUpdateManyWithoutOrganizationsInput
  customers: CustomerUpdateManyWithoutOrganizationsInput
}

input OrganizationUpdateWithWhereUniqueWithoutAdminsInput {
  where: OrganizationWhereUniqueInput!
  data: OrganizationUpdateWithoutAdminsDataInput!
}

input OrganizationUpdateWithWhereUniqueWithoutCustomersInput {
  where: OrganizationWhereUniqueInput!
  data: OrganizationUpdateWithoutCustomersDataInput!
}

input OrganizationUpsertWithoutMenusInput {
  update: OrganizationUpdateWithoutMenusDataInput!
  create: OrganizationCreateWithoutMenusInput!
}

input OrganizationUpsertWithWhereUniqueWithoutAdminsInput {
  where: OrganizationWhereUniqueInput!
  update: OrganizationUpdateWithoutAdminsDataInput!
  create: OrganizationCreateWithoutAdminsInput!
}

input OrganizationUpsertWithWhereUniqueWithoutCustomersInput {
  where: OrganizationWhereUniqueInput!
  update: OrganizationUpdateWithoutCustomersDataInput!
  create: OrganizationCreateWithoutCustomersInput!
}

input OrganizationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  menus_every: MenuWhereInput
  menus_some: MenuWhereInput
  menus_none: MenuWhereInput
  admins_every: UserWhereInput
  admins_some: UserWhereInput
  admins_none: UserWhereInput
  customers_every: CustomerWhereInput
  customers_some: CustomerWhereInput
  customers_none: CustomerWhereInput
  AND: [OrganizationWhereInput!]
  OR: [OrganizationWhereInput!]
  NOT: [OrganizationWhereInput!]
}

input OrganizationWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

enum Permission {
  DEVELOPER
  DIRECTOR
  ADMIN
  CUSTOMER
}

type Query {
  cart(where: CartWhereUniqueInput!): Cart
  carts(where: CartWhereInput, orderBy: CartOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Cart]!
  cartsConnection(where: CartWhereInput, orderBy: CartOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CartConnection!
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Customer]!
  customersConnection(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CustomerConnection!
  menu(where: MenuWhereUniqueInput!): Menu
  menus(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Menu]!
  menusConnection(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MenuConnection!
  menuChoice(where: MenuChoiceWhereUniqueInput!): MenuChoice
  menuChoices(where: MenuChoiceWhereInput, orderBy: MenuChoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuChoice]!
  menuChoicesConnection(where: MenuChoiceWhereInput, orderBy: MenuChoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MenuChoiceConnection!
  menuHeader(where: MenuHeaderWhereUniqueInput!): MenuHeader
  menuHeaders(where: MenuHeaderWhereInput, orderBy: MenuHeaderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuHeader]!
  menuHeadersConnection(where: MenuHeaderWhereInput, orderBy: MenuHeaderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MenuHeaderConnection!
  menuItem(where: MenuItemWhereUniqueInput!): MenuItem
  menuItems(where: MenuItemWhereInput, orderBy: MenuItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuItem]!
  menuItemsConnection(where: MenuItemWhereInput, orderBy: MenuItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MenuItemConnection!
  menuSelection(where: MenuSelectionWhereUniqueInput!): MenuSelection
  menuSelections(where: MenuSelectionWhereInput, orderBy: MenuSelectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuSelection]!
  menuSelectionsConnection(where: MenuSelectionWhereInput, orderBy: MenuSelectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MenuSelectionConnection!
  order(where: OrderWhereUniqueInput!): Order
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order]!
  ordersConnection(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderConnection!
  orderItem(where: OrderItemWhereUniqueInput!): OrderItem
  orderItems(where: OrderItemWhereInput, orderBy: OrderItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderItem]!
  orderItemsConnection(where: OrderItemWhereInput, orderBy: OrderItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderItemConnection!
  organization(where: OrganizationWhereUniqueInput!): Organization
  organizations(where: OrganizationWhereInput, orderBy: OrganizationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Organization]!
  organizationsConnection(where: OrganizationWhereInput, orderBy: OrganizationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrganizationConnection!
  table(where: TableWhereUniqueInput!): Table
  tables(where: TableWhereInput, orderBy: TableOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Table]!
  tablesConnection(where: TableWhereInput, orderBy: TableOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TableConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  cart(where: CartSubscriptionWhereInput): CartSubscriptionPayload
  customer(where: CustomerSubscriptionWhereInput): CustomerSubscriptionPayload
  menu(where: MenuSubscriptionWhereInput): MenuSubscriptionPayload
  menuChoice(where: MenuChoiceSubscriptionWhereInput): MenuChoiceSubscriptionPayload
  menuHeader(where: MenuHeaderSubscriptionWhereInput): MenuHeaderSubscriptionPayload
  menuItem(where: MenuItemSubscriptionWhereInput): MenuItemSubscriptionPayload
  menuSelection(where: MenuSelectionSubscriptionWhereInput): MenuSelectionSubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  orderItem(where: OrderItemSubscriptionWhereInput): OrderItemSubscriptionPayload
  organization(where: OrganizationSubscriptionWhereInput): OrganizationSubscriptionPayload
  table(where: TableSubscriptionWhereInput): TableSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Table {
  id: ID!
  customers(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  carts(where: CartWhereInput, orderBy: CartOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Cart!]
}

type TableConnection {
  pageInfo: PageInfo!
  edges: [TableEdge]!
  aggregate: AggregateTable!
}

input TableCreateInput {
  id: ID
  customers: UserCreateManyInput
  carts: CartCreateManyWithoutTableInput
}

input TableCreateOneInput {
  create: TableCreateInput
  connect: TableWhereUniqueInput
}

input TableCreateOneWithoutCartsInput {
  create: TableCreateWithoutCartsInput
  connect: TableWhereUniqueInput
}

input TableCreateWithoutCartsInput {
  id: ID
  customers: UserCreateManyInput
}

type TableEdge {
  node: Table!
  cursor: String!
}

enum TableOrderByInput {
  id_ASC
  id_DESC
}

type TablePreviousValues {
  id: ID!
}

type TableSubscriptionPayload {
  mutation: MutationType!
  node: Table
  updatedFields: [String!]
  previousValues: TablePreviousValues
}

input TableSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TableWhereInput
  AND: [TableSubscriptionWhereInput!]
  OR: [TableSubscriptionWhereInput!]
  NOT: [TableSubscriptionWhereInput!]
}

input TableUpdateDataInput {
  customers: UserUpdateManyInput
  carts: CartUpdateManyWithoutTableInput
}

input TableUpdateInput {
  customers: UserUpdateManyInput
  carts: CartUpdateManyWithoutTableInput
}

input TableUpdateOneInput {
  create: TableCreateInput
  update: TableUpdateDataInput
  upsert: TableUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TableWhereUniqueInput
}

input TableUpdateOneWithoutCartsInput {
  create: TableCreateWithoutCartsInput
  update: TableUpdateWithoutCartsDataInput
  upsert: TableUpsertWithoutCartsInput
  delete: Boolean
  disconnect: Boolean
  connect: TableWhereUniqueInput
}

input TableUpdateWithoutCartsDataInput {
  customers: UserUpdateManyInput
}

input TableUpsertNestedInput {
  update: TableUpdateDataInput!
  create: TableCreateInput!
}

input TableUpsertWithoutCartsInput {
  update: TableUpdateWithoutCartsDataInput!
  create: TableCreateWithoutCartsInput!
}

input TableWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  customers_every: UserWhereInput
  customers_some: UserWhereInput
  customers_none: UserWhereInput
  carts_every: CartWhereInput
  carts_some: CartWhereInput
  carts_none: CartWhereInput
  AND: [TableWhereInput!]
  OR: [TableWhereInput!]
  NOT: [TableWhereInput!]
}

input TableWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  email: String!
  name: String
  password: String!
  organizations(where: OrganizationWhereInput, orderBy: OrganizationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Organization!]
  permissions: Permission!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  name: String
  password: String!
  organizations: OrganizationCreateManyWithoutAdminsInput
  permissions: Permission
}

input UserCreateManyInput {
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutOrganizationsInput {
  create: [UserCreateWithoutOrganizationsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutOrganizationsInput {
  id: ID
  email: String!
  name: String
  password: String!
  permissions: Permission
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  name_ASC
  name_DESC
  password_ASC
  password_DESC
  permissions_ASC
  permissions_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  name: String
  password: String!
  permissions: Permission!
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  permissions: Permission
  permissions_not: Permission
  permissions_in: [Permission!]
  permissions_not_in: [Permission!]
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  email: String
  name: String
  password: String
  organizations: OrganizationUpdateManyWithoutAdminsInput
  permissions: Permission
}

input UserUpdateInput {
  email: String
  name: String
  password: String
  organizations: OrganizationUpdateManyWithoutAdminsInput
  permissions: Permission
}

input UserUpdateManyDataInput {
  email: String
  name: String
  password: String
  permissions: Permission
}

input UserUpdateManyInput {
  create: [UserCreateInput!]
  update: [UserUpdateWithWhereUniqueNestedInput!]
  upsert: [UserUpsertWithWhereUniqueNestedInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyMutationInput {
  email: String
  name: String
  password: String
  permissions: Permission
}

input UserUpdateManyWithoutOrganizationsInput {
  create: [UserCreateWithoutOrganizationsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutOrganizationsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutOrganizationsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutOrganizationsDataInput {
  email: String
  name: String
  password: String
  permissions: Permission
}

input UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  data: UserUpdateDataInput!
}

input UserUpdateWithWhereUniqueWithoutOrganizationsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutOrganizationsDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithWhereUniqueWithoutOrganizationsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutOrganizationsDataInput!
  create: UserCreateWithoutOrganizationsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  organizations_every: OrganizationWhereInput
  organizations_some: OrganizationWhereInput
  organizations_none: OrganizationWhereInput
  permissions: Permission
  permissions_not: Permission
  permissions_in: [Permission!]
  permissions_not_in: [Permission!]
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`